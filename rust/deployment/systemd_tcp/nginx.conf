# utilisateur/groupe des processus worker. Le master processus nginx est toujours lancé en root.
user www-data www-data;
# un seul processus worker pour le benchmark seulement, en production, mettre auto ou nb_core/2 (cf doc)
worker_processes 1;
# le nombre de fichier simultané qu'un worker peut ouvrir, limité également par l'OS.
worker_rlimit_nofile 2048;
# pidfile
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

events {
	# nombre de connexions simultanées maximum ouvertes par un seul worker nginx. worker_connection < worker_rlimit_nofile
	# En pratique, 32 suffisait déjà à avoir des performances maximales.
	worker_connections 64;
	# si "on", un worker traite toutes les connexions en même temps. En pratique, je ne pense pas avoir très bien compris puisque quand je mets on,
	# les performances chutent drastiquement
	multi_accept off;
	# epoll permet de surveiller et de réagir aux modifications d'un fichier, pour un webserver c'est pour les sockets que c'est intéressant.
	# nginx ne réinvente pas la roue et utilise ce que l'os lui donne pour surveiller la modification d'un socket. Nginx peut donc lancer plusieurs
	# workers qui écoutent sur le même socket grâce à epoll. Nginx essaiera de prendre la meilleure méthode si on lui donne pas explicitement une.
	# Dépendant du système d'exploitation. Non disponible sur Windows par ex. Une des raisons pour lesquelles Nginx est moins bien sur Windows.
	use epoll;
}

http {

	##
	# Basic Settings
	##
	# j'ai pas compris ce que ça faisait
	sendfile on;
	tcp_nopush on;
	tcp_nodelay on;
	types_hash_max_size 2048;

	include /etc/nginx/mime.types;
	default_type application/octet-stream;

	##
	# SSL Settings
	##
	# par défaut ici

	ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE
	ssl_prefer_server_ciphers on;

	##
	# Logging Settings
	##
	# d'après la doc, le buffer est par défaut à 64K mais quand je le mets explicitement à 64K, j'ai de meilleur performance.
	# ici on bufferise les écritures sur access.log, ce qui donne meilleur perf
	access_log /var/log/nginx/access.log combined buffer=64K;
	# Pas forcément une bonne idée de bufferiser les erreurs..., de toute façon ça n'apporte pas grand chose
	error_log /var/log/nginx/error.log;

	# on configure le cache
	proxy_cache_path /var/log/nginx/cache levels=1:2 keys_zone=test:10m max_size=10g inactive=30s ;
	# Pour des raisons obscures, si on ne met pas cette ligne, le cache refuse de fonctionner. Seule une issue github datant de 2016 a reporté ce bug.
	# La doc nginx nen parle pas, ici la taille du cache est limitée à 10g. Les entrées inactives sont supprimées au bout de 30 secondes.
	# Jais pas compris pk y avait test:10m (10 mega) et max_size...

	# temps de validité du cache. Ca marche vraiment pas (30 secondes ici) mais si on met pas cette ligne inutile, pas de cache.
	proxy_cache_valid any 10s;

	# Attention, les headers des paquets prévalent sur la configuration de Nginx. Ainsi, si un header contient Cache-Control, la requête ne sera pas mise en cache.
	# c'est alors au client (firefox) de se charger du cache.
	# On peut forcer Nginx à ignorer ces headers

	##
	# Gzip Settings
	##

	# En production on mettrait gzip évidemmment. Mais là, on fait un benchmark
	gzip off;

	gzip_vary off;
	# paramètre par défaut que j'ai trouvé sur internet, aucune idée d'à quoi ils servent mais ça peut être bien d'explorer.
	# gzip_proxied any;
	# gzip_comp_level 6;
	# gzip_buffers 16 8k;
	# gzip_http_version 1.1;
	# gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
	##
	# Virtual Host Configs
	##

	include /etc/nginx/conf.d/*.conf;
	include /etc/nginx/sites-enabled/*;
}
